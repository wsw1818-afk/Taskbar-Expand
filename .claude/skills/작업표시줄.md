# WPF Windows 11 스타일 보조 작업 표시줄 개발 가이드

## 개요
Windows 11 스타일의 보조 작업 표시줄 앱(TaskbarExpand) 개발 시 겪었던 문제와 해결 방법을 정리한 문서입니다.

---

## 1. 스크린샷 시 앱 종료 문제

### 문제
`WindowStyle="ToolWindow"` 설정 시 PrintScreen(스크린샷) 누르면 앱이 종료됨

### 해결
```xml
<!-- 변경 전 -->
<Window WindowStyle="ToolWindow" ... />

<!-- 변경 후 -->
<Window WindowStyle="None"
        AllowsTransparency="True"
        ResizeMode="NoResize" ... />
```

### 주의사항
- `AllowsTransparency="True"` 필수 (투명 배경 사용 시)
- `ResizeMode="NoResize"` 설정 안 하면 흰색 ResizeGrip 사각형이 나타남

---

## 2. AppBar API (다른 창 자동 리사이즈)

### 목적
앱이 화면 가장자리에 고정되면 다른 창들이 자동으로 공간을 피해 리사이즈

### 필수 NativeMethods
```csharp
// 상수
public const int ABM_NEW = 0;
public const int ABM_REMOVE = 1;
public const int ABM_QUERYPOS = 2;
public const int ABM_SETPOS = 3;
public const int ABE_RIGHT = 2;    // 오른쪽 edge
public const int ABE_BOTTOM = 3;   // 하단 edge

// 구조체
[StructLayout(LayoutKind.Sequential)]
public struct APPBARDATA
{
    public int cbSize;
    public IntPtr hWnd;
    public uint uCallbackMessage;
    public uint uEdge;
    public RECT rc;
    public int lParam;
}

[StructLayout(LayoutKind.Sequential)]
public struct RECT
{
    public int left, top, right, bottom;
}

// 함수
[DllImport("shell32.dll")]
public static extern uint SHAppBarMessage(uint dwMessage, ref APPBARDATA pData);
```

### AppBar 등록/해제
```csharp
private bool _isAppBarRegistered;
private IntPtr _hwnd;

private void RegisterAppBar()
{
    if (_isAppBarRegistered) return;

    var abd = new NativeMethods.APPBARDATA
    {
        cbSize = Marshal.SizeOf(typeof(NativeMethods.APPBARDATA)),
        hWnd = _hwnd
    };

    if (NativeMethods.SHAppBarMessage(NativeMethods.ABM_NEW, ref abd) != 0)
    {
        _isAppBarRegistered = true;
        SetAppBarPos();
    }
}

private void UnregisterAppBar()
{
    if (!_isAppBarRegistered) return;

    var abd = new NativeMethods.APPBARDATA
    {
        cbSize = Marshal.SizeOf(typeof(NativeMethods.APPBARDATA)),
        hWnd = _hwnd
    };

    NativeMethods.SHAppBarMessage(NativeMethods.ABM_REMOVE, ref abd);
    _isAppBarRegistered = false;
}
```

### AppBar 위치 설정 (세로/가로 모드)
```csharp
private void SetAppBarPos()
{
    if (!_isAppBarRegistered) return;

    var screen = _currentScreen ?? System.Windows.Forms.Screen.PrimaryScreen;
    if (screen == null) return;

    // WorkingArea 사용 (Windows 작업 표시줄 제외 영역)
    var workArea = screen.WorkingArea;
    NativeMethods.APPBARDATA abd;

    if (_isHorizontalMode)
    {
        // 가로 모드: 하단 배치
        abd = new NativeMethods.APPBARDATA
        {
            cbSize = Marshal.SizeOf(typeof(NativeMethods.APPBARDATA)),
            hWnd = _hwnd,
            uEdge = NativeMethods.ABE_BOTTOM,
            rc = new NativeMethods.RECT
            {
                left = workArea.Left,
                top = workArea.Bottom - height,
                right = workArea.Right,
                bottom = workArea.Bottom
            }
        };
    }
    else
    {
        // 세로 모드: 오른쪽 배치
        abd = new NativeMethods.APPBARDATA
        {
            cbSize = Marshal.SizeOf(typeof(NativeMethods.APPBARDATA)),
            hWnd = _hwnd,
            uEdge = NativeMethods.ABE_RIGHT,
            rc = new NativeMethods.RECT
            {
                left = workArea.Right - APPBAR_WIDTH,
                top = workArea.Top,
                right = workArea.Right,
                bottom = workArea.Bottom
            }
        };
    }

    NativeMethods.SHAppBarMessage(NativeMethods.ABM_QUERYPOS, ref abd);
    NativeMethods.SHAppBarMessage(NativeMethods.ABM_SETPOS, ref abd);

    // 창 위치/크기 적용
    Width = abd.rc.right - abd.rc.left;
    Height = abd.rc.bottom - abd.rc.top;
    Left = abd.rc.left;
    Top = abd.rc.top;
}
```

### 중요: WorkingArea vs Bounds
- `screen.Bounds`: 전체 화면 (작업 표시줄 포함)
- `screen.WorkingArea`: 작업 표시줄 제외한 사용 가능 영역
- **항상 WorkingArea 사용해야 Windows 작업 표시줄과 겹치지 않음**

---

## 3. 듀얼 모니터 지원

### 마우스 커서 위치로 모니터 감지
```csharp
// csproj에 추가 필요
<UseWindowsForms>true</UseWindowsForms>

// Window_Loaded에서
var cursorPos = System.Windows.Forms.Cursor.Position;
_currentScreen = System.Windows.Forms.Screen.FromPoint(cursorPos);
```

### 절대 좌표 사용
- 듀얼 모니터에서는 `screen.Bounds.Left`, `screen.Bounds.Right` 등 절대 좌표 사용
- `SystemParameters.PrimaryScreenWidth`는 주 모니터만 해당

---

## 4. 자동 숨김 기능

### 구조
```csharp
private bool _isAutoHideEnabled;
private bool _isHidden;
private DispatcherTimer? _autoHideTimer;      // 마우스 위치 감지 (50ms)
private DispatcherTimer? _hideDelayTimer;     // 숨김 지연 (300ms)
```

### 가장자리 감지
```csharp
private bool IsMouseAtEdge(System.Drawing.Point cursorPos, System.Windows.Forms.Screen screen)
{
    var workArea = screen.WorkingArea;
    const int EDGE_DETECTION_SIZE = 8;  // 감지 영역 크기

    if (_isHorizontalMode)
    {
        // 하단 가장자리
        return cursorPos.Y >= workArea.Bottom - EDGE_DETECTION_SIZE &&
               cursorPos.Y <= workArea.Bottom &&
               cursorPos.X >= workArea.Left &&
               cursorPos.X <= workArea.Right;
    }
    else
    {
        // 오른쪽 가장자리
        return cursorPos.X >= workArea.Right - EDGE_DETECTION_SIZE &&
               cursorPos.X <= workArea.Right &&
               cursorPos.Y >= workArea.Top &&
               cursorPos.Y <= workArea.Bottom;
    }
}
```

### 숨김 지연 (사용자 경험 개선)
- 마우스가 벗어나도 즉시 숨기지 않음
- 300ms 후 숨김 → 실수로 벗어났을 때 대응
- 다시 창 위로 가면 지연 타이머 취소

---

## 5. 비동기 아이콘 로딩 (성능 최적화)

### 문제
- `Process.GetProcessById()` + `ExtractAssociatedIcon()` 동기 호출 시 UI 버벅임

### 해결
```csharp
private static readonly ConcurrentDictionary<string, BitmapSource?> _iconCache = new();
private static readonly ConcurrentDictionary<string, bool> _loadingPaths = new();

private async void LoadIconAsync()
{
    if (string.IsNullOrEmpty(ProcessPath)) return;

    // 중복 로딩 방지
    if (!_loadingPaths.TryAdd(ProcessPath, true))
    {
        await Task.Delay(100);
        if (_iconCache.TryGetValue(ProcessPath, out var icon))
            Icon = icon;
        return;
    }

    try
    {
        var path = ProcessPath;
        var icon = await Task.Run(() => ExtractIcon(path));

        if (icon != null)
        {
            _iconCache.TryAdd(path, icon);
            Application.Current?.Dispatcher?.Invoke(() => Icon = icon);
        }
    }
    finally
    {
        _loadingPaths.TryRemove(ProcessPath, out _);
    }
}

private static BitmapSource? ExtractIcon(string path)
{
    try
    {
        using var icon = System.Drawing.Icon.ExtractAssociatedIcon(path);
        if (icon == null) return null;

        var bmp = System.Windows.Interop.Imaging.CreateBitmapSourceFromHIcon(
            icon.Handle,
            Int32Rect.Empty,
            BitmapSizeOptions.FromEmptyOptions());
        bmp.Freeze();  // 스레드 안전 + 성능
        return bmp;
    }
    catch { return null; }
}
```

### 핵심 포인트
- `bmp.Freeze()` 필수 - 다른 스레드에서 사용 가능하게 함
- `ConcurrentDictionary`로 캐시 및 로딩 상태 관리
- UI 업데이트는 `Dispatcher.Invoke()` 사용

---

## 6. 초기 로딩 최적화

### UI 렌더링 후 데이터 로드
```csharp
private void Window_Loaded(object sender, RoutedEventArgs e)
{
    // ... 초기 설정 ...

    // UI 렌더링 완료 후 창 목록 로드 (버벅임 방지)
    Dispatcher.BeginInvoke(DispatcherPriority.Background, () =>
    {
        RefreshWindowList();
        _refreshTimer?.Start();
    });
}
```

---

## 7. 창 포커스 방지

### 클릭해도 포커스 가져가지 않게
```csharp
private void Window_Loaded(object sender, RoutedEventArgs e)
{
    _hwnd = new WindowInteropHelper(this).Handle;

    var exStyle = NativeMethods.GetWindowLong(_hwnd, NativeMethods.GWL_EXSTYLE);
    NativeMethods.SetWindowLong(_hwnd, NativeMethods.GWL_EXSTYLE,
        exStyle | NativeMethods.WS_EX_NOACTIVATE);
}
```

---

## 8. Windows 11 스타일 UI

### 반투명 배경
```xml
<SolidColorBrush x:Key="TaskbarBackgroundBrush" Color="#E8202020"/>
```

### 둥근 모서리
```xml
<Border CornerRadius="8" ... />
```

### 호버 효과
```xml
<Style x:Key="Win11ButtonStyle" TargetType="Button">
    <Setter Property="Background" Value="Transparent"/>
    <Style.Triggers>
        <Trigger Property="IsMouseOver" Value="True">
            <Setter Property="Background" Value="#40FFFFFF"/>
        </Trigger>
    </Style.Triggers>
</Style>
```

---

## 9. 드래그 앤 드롭 (창 순서 변경)

```csharp
private void ListBox_PreviewMouseMove(object sender, MouseEventArgs e)
{
    if (e.LeftButton != MouseButtonState.Pressed || _isDragging) return;
    if (sender is not ListBox lb) return;

    var pos = e.GetPosition(lb);
    if (Math.Abs(pos.X - _dragStartPoint.X) > SystemParameters.MinimumHorizontalDragDistance ||
        Math.Abs(pos.Y - _dragStartPoint.Y) > SystemParameters.MinimumVerticalDragDistance)
    {
        var item = GetListBoxItemAt(lb, pos);
        if (item?.DataContext is WindowInfo w)
        {
            _isDragging = true;
            DragDrop.DoDragDrop(lb, w, DragDropEffects.Move);
            _isDragging = false;
        }
    }
}

private void ListBox_Drop(object sender, DragEventArgs e)
{
    if (sender is not ListBox lb ||
        e.Data.GetData(typeof(WindowInfo)) is not WindowInfo dropped) return;

    var target = GetListBoxItemAt(lb, e.GetPosition(lb))?.DataContext as WindowInfo;
    int oldIdx = _windows.IndexOf(dropped);
    int newIdx = target != null ? _windows.IndexOf(target) : _windows.Count - 1;

    if (oldIdx >= 0 && newIdx >= 0 && oldIdx != newIdx)
        _windows.Move(oldIdx, newIdx);
}
```

---

## 10. 같은 앱끼리 그룹화

```csharp
private void GroupByAppButton_Click(object sender, RoutedEventArgs e)
{
    var grouped = _windows
        .GroupBy(w => w.ProcessPath ?? w.ProcessId.ToString())
        .SelectMany(g => g)
        .ToList();

    for (int i = 0; i < grouped.Count; i++)
    {
        int currentIndex = _windows.IndexOf(grouped[i]);
        if (currentIndex != i)
            _windows.Move(currentIndex, i);
    }
}
```

---

## 11. Self-Contained 단일 파일 배포

### 빌드 명령
```bash
dotnet publish -c Release -r win-x64 --self-contained true \
    -p:PublishSingleFile=true \
    -p:IncludeNativeLibrariesForSelfExtract=true \
    -o "출력폴더"
```

### 중요
- `IncludeNativeLibrariesForSelfExtract=true` 없으면 앱 실행 시 멈춤 현상 발생
- 결과물 약 155MB (런타임 포함)

---

## 12. 흔한 버그와 해결

| 문제 | 원인 | 해결 |
|------|------|------|
| 흰색 사각형 나타남 | ResizeGrip | `ResizeMode="NoResize"` |
| Windows 작업표시줄과 겹침 | Bounds 사용 | WorkingArea 사용 |
| 모드 전환 시 앱 종료 | 예외 미처리 | try-catch 추가 |
| 아이콘 로딩 시 버벅임 | 동기 로딩 | 비동기 + 캐시 |
| 듀얼 모니터에서 잘못된 위치 | PrimaryScreen 사용 | 마우스 위치로 모니터 감지 |

---

## 파일 구조
```
TaskbarExpand/
├── MainWindow.xaml          # UI 정의
├── MainWindow.xaml.cs       # 메인 로직
├── WindowInfo.cs            # 창 정보 + 아이콘 캐시
├── NativeMethods.cs         # Win32 API 선언
└── TaskbarExpand.csproj     # 프로젝트 설정
```
